<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Bible Verse Ordering Game (v02)</title>
  <style>
    :root{
      --bg:#0b1120; --card:#0f172a; --line:#1f2937;
      --text:#e5e7eb; --sub:#9ca3af; --accent:#38bdf8;
      --good:#22c55e; --bad:#ef4444; --warn:#f59e0b;
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --r: 18px;

      /* dynamic verse font size */
      --verse-font: 14px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; padding:16px;
      background:linear-gradient(180deg,#0b1120,#020617);
      color:var(--text);
      font-family:system-ui,-apple-system,"Apple SD Gothic Neo","Noto Sans KR",sans-serif;
    }
    .wrap{max-width:1100px;margin:0 auto}
    h1{margin:0 0 12px;font-size:20px;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .pill{
      display:inline-block;
      font-size:12px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.25);
      color:var(--sub);
    }

    /* Main page (Selection + Command Buttons on one screen) */
    .grid{display:grid;gap:12px;grid-template-columns:1fr}
    @media(min-width:980px){
      .grid{grid-template-columns: 420px 1fr;}
    }

    .card{
      background:rgba(15,23,42,.95);
      border:1px solid rgba(31,41,55,.85);
      border-radius:var(--r);
      padding:14px;
      box-shadow:var(--shadow);
    }
    .sectionTitle{
      font-size:14px;
      color:#bae6fd;
      margin:0 0 10px;
      display:flex; align-items:center; gap:8px;
    }
    label{display:block;font-size:12px;color:var(--sub);margin:10px 0 6px}
    select,button{
      width:100%;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(31,41,55,.9);
      background:#0b1223;
      color:var(--text);
      font-size:14px;
    }
    button{cursor:pointer}
    button.primary{background:rgba(56,189,248,.14); border-color:rgba(56,189,248,.38)}
    button.ghost{background:transparent}
    button:disabled{opacity:.55; cursor:not-allowed}

    .row{display:flex;gap:10px;flex-wrap:wrap}
    .row > button{flex:1 1 140px}

    .hintBox{
      margin-top:10px;
      padding:10px 12px;
      border-radius:14px;
      border:1px dashed rgba(148,163,184,.25);
      background:rgba(2,6,23,.35);
      color:var(--sub);
      font-size:13px;
      line-height:1.55;
    }

    /* Generic modal */
    .modalOverlay{
      position:fixed; inset:0;
      background:rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:999;
    }
    .modal{
      width:min(860px, 100%);
      background:rgba(15,23,42,.98);
      border:1px solid rgba(31,41,55,.9);
      border-radius:20px;
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .modalHeader{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      padding:12px 14px;
      border-bottom:1px solid rgba(31,41,55,.85);
      background:rgba(2,6,23,.35);
    }
    .modalTitle{margin:0;font-size:15px;color:#bae6fd}
    .modalBody{padding:14px}
    .modalFooter{
      padding:12px 14px;
      border-top:1px solid rgba(31,41,55,.85);
      background:rgba(2,6,23,.35);
      display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap;
    }
    .closeBtn{
      width:auto;
      padding:8px 10px;
      border-radius:12px;
      background:transparent;
    }

    .resultBadge{
      display:inline-block;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.25);
      font-size:13px;
      margin-bottom:10px;
    }
    .success{border-color:rgba(34,197,94,.5); color:#bbf7d0; background:rgba(34,197,94,.12)}
    .fail{border-color:rgba(239,68,68,.5); color:#fecaca; background:rgba(239,68,68,.12)}
    .warn{border-color:rgba(245,158,11,.5); color:#fde68a; background:rgba(245,158,11,.12)}

    /* Game modal (v02) */
    .gameTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .gameRef{
      color:#e0f2fe;
      font-size:14px;
      margin:0;
    }
    .list{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:12px;
    }
    .item{
      border:1px solid rgba(31,41,55,.85);
      background:rgba(2,6,23,.45);
      border-radius:16px;
      padding:12px;
      display:flex;
      gap:10px;
      align-items:flex-start;
      user-select:none;
      touch-action:none; /* for pointer dragging on mobile */
    }
    .grab{
      width:34px;
      flex:0 0 auto;
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius:12px;
      border:1px solid rgba(56,189,248,.30);
      background:rgba(56,189,248,.10);
      color:#bae6fd;
      font-size:16px;
      line-height:1;
      padding:6px 0;
      cursor:grab;
    }
    .item.dragging{
      opacity:.7;
      outline:2px solid rgba(56,189,248,.45);
    }
    .text{
      font-size:var(--verse-font);
      line-height:1.6;
      word-break:keep-all;
      flex:1 1 auto;
    }

    /* Footer button bar in one line (v02 requirement) */
    .bar{
      display:flex;
      gap:10px;
      flex-wrap:nowrap;
      align-items:center;
      justify-content:space-between;
    }
    .bar button{
      width:auto;
      flex:1 1 0;
      padding:10px 8px;
      border-radius:14px;
      font-size:13px;
      white-space:nowrap;
    }
    @media(max-width:520px){
      .bar{gap:8px}
      .bar button{font-size:12px; padding:10px 6px}
    }

    /* Answer lines */
    .answerLine{
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(31,41,55,.75);
      background:rgba(2,6,23,.35);
      margin-bottom:10px;
    }
    .answerLine:last-child{margin-bottom:0}
    .meta{font-size:12px;color:var(--sub);margin-bottom:6px}
  </style>
</head>

<body>
<div class="wrap">
  <h1>
    Bible Verse Ordering Game
    <span class="pill">requirement v02 (frozen)</span>
    <span class="pill" id="nPill">N=5</span>
  </h1>

  <div class="grid">
    <!-- LEFT: Selection + Commands -->
    <div class="card">
      <div class="sectionTitle">Selection Section <span class="pill">권 → 장 → 절</span></div>

      <label>권 (Book)</label>
      <select id="bookSel"></select>

      <label>장 (Chapter)</label>
      <select id="chapSel"></select>

      <label>절 (Verse) <span class="pill">start</span></label>
      <select id="verseSel"></select>

      <div style="height:14px"></div>

      <div class="sectionTitle">Command Button Section</div>
      <div class="row">
        <button class="primary" id="startBtn">게임 시작</button>
        <button id="settingsBtn">게임 설정</button>
      </div>

      <div class="hintBox">
        • v02: 게임 화면은 팝업에서 드래그로 정렬합니다.<br/>
        • N은 게임 설정(5~10)에서 변경합니다.<br/>
        • 장 끝이면 N보다 적어도 게임이 진행됩니다.<br/>
        • 상태 저장 키: <b>bible_game_state_v01</b> (권/장/절(start)/N 저장)
      </div>
    </div>

    <!-- RIGHT: Summary / Status -->
    <div class="card">
      <div class="sectionTitle">Status</div>
      <div class="hintBox" style="margin-top:0">
        <div><b>현재 선택</b>: <span id="statusSel">-</span></div>
        <div><b>설정</b>: 연속 구절 수 N = <span id="statusN">5</span></div>
        <div style="margin-top:8px; color:var(--sub)">
          “게임 시작”을 누르면 게임 팝업이 열립니다.
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Generic Modal (notifications/settings/answer) -->
<div class="modalOverlay" id="overlay">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="modalHeader">
      <h2 class="modalTitle" id="modalTitle">Popup</h2>
      <button class="closeBtn" id="modalClose">닫기</button>
    </div>
    <div class="modalBody" id="modalBody"></div>
    <div class="modalFooter" id="modalFooter"></div>
  </div>
</div>

<!-- Game Modal (v02) -->
<div class="modalOverlay" id="gameOverlay">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="gameTitle">
    <div class="modalHeader">
      <div class="gameTop">
        <h2 class="modalTitle" id="gameTitle">게임</h2>
        <p class="gameRef" id="gameRef">-</p>
      </div>
      <button class="closeBtn" id="gameX">닫기</button>
    </div>

    <div class="modalBody">
      <div class="list" id="gameList"></div>
    </div>

    <!-- v02: one-line button bar INSIDE game popup -->
    <div class="modalFooter">
      <div class="bar" style="width:100%">
        <button id="btnCheck">결과 확인</button>
        <button class="ghost" id="btnReplay">다시하기</button>
        <button class="ghost" id="btnAnswer">정답 화면</button>
        <button class="primary" id="btnClose">닫기</button>
      </div>
    </div>
  </div>
</div>

<script>
/* =========================================================
   requirement v02 (frozen) Implementation
   - Game execution moved to a popup
   - In-game popup has 1-line buttons: Check / Replay / Answer / Close
   - Ordering via Drag (pointer-based, mobile-friendly)
   - Keeps v01 frozen rules: data load, N(5~10 default 5), end-of-chapter allowed,
     persistence key bible_game_state_v01 saving book/chap/verse(start)/N
     save times: start / next section (not used in UI here) / save settings
========================================================= */

const STORAGE_KEY = "bible_game_state_v01";

let RAW = null;
let BIBLE = null;

let settings = { n: 5 }; // min 5 max 10 default 5
let sel = { book:null, chap:null, verse:null };

let correctSet = [];
let shuffled = [];

/* ========== DOM ========== */
const $ = (id)=>document.getElementById(id);

const bookSel = $("bookSel");
const chapSel = $("chapSel");
const verseSel = $("verseSel");
const startBtn = $("startBtn");
const settingsBtn = $("settingsBtn");

const overlay = $("overlay");
const modalTitle = $("modalTitle");
const modalBody = $("modalBody");
const modalFooter = $("modalFooter");
const modalClose = $("modalClose");

const gameOverlay = $("gameOverlay");
const gameX = $("gameX");
const gameList = $("gameList");
const gameRef = $("gameRef");

const btnCheck = $("btnCheck");
const btnReplay = $("btnReplay");
const btnAnswer = $("btnAnswer");
const btnClose = $("btnClose");

const nPill = $("nPill");
const statusSel = $("statusSel");
const statusN = $("statusN");

/* ========== Modal helpers ========== */
function openModal(title, bodyHtml, footerButtons=[]) {
  modalTitle.textContent = title;
  modalBody.innerHTML = bodyHtml;
  modalFooter.innerHTML = "";
  for (const btn of footerButtons) modalFooter.appendChild(btn);
  overlay.style.display = "flex";
}
function closeModal() {
  overlay.style.display = "none";
  modalBody.innerHTML = "";
  modalFooter.innerHTML = "";
}
modalClose.addEventListener("click", closeModal);
overlay.addEventListener("click", (e)=>{ if(e.target === overlay) closeModal(); });

function mkButton(text, cls, onClick) {
  const b = document.createElement("button");
  b.textContent = text;
  if (cls) b.className = cls;
  b.style.width = "auto";
  b.addEventListener("click", onClick);
  return b;
}
function escapeHtml(s){
  return String(s)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
function openAlert(msg, title="알림 화면"){
  const body = `
    <div class="resultBadge warn">알림</div>
    <div class="hintBox" style="margin:0">${escapeHtml(msg).replaceAll("\n","<br/>")}</div>
  `;
  const okBtn = mkButton("확인", "primary", closeModal);
  openModal(title, body, [okBtn]);
}

/* ========== Game modal helpers ========== */
function openGameModal(){
  gameOverlay.style.display = "flex";
}
function closeGameModal(){
  gameOverlay.style.display = "none";
}
gameX.addEventListener("click", closeGameModal);
btnClose.addEventListener("click", closeGameModal);
gameOverlay.addEventListener("click", (e)=>{ if(e.target === gameOverlay) closeGameModal(); });

/* ========== Data load/normalize ========== */
function normalizeBibleJson(raw){
  if (raw && typeof raw === "object" && raw.chapters && (raw.book_name_kr || raw.book_name)) {
    const name = raw.book_name_kr || raw.book_name;
    return { [name]: raw.chapters };
  }
  if (raw && typeof raw === "object" && !Array.isArray(raw) && !raw.chapters) {
    return raw;
  }
  return null;
}

async function loadData(){
  if (location.protocol === "file:") {
    openAlert(
      "현재 file:// 로 실행 중이라 verse_krv.json을 읽을 수 없습니다.\n\n" +
      "GitHub Pages 또는 로컬 서버(VSCode Live Server)로 실행하세요."
    );
    return false;
  }

  try{
    const res = await fetch("./verse_krv.json", { cache:"no-store" });
    if(!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
    const text = await res.text();
    RAW = JSON.parse(text);
    BIBLE = normalizeBibleJson(RAW);
    if(!BIBLE || Object.keys(BIBLE).length === 0) throw new Error("Normalized bible is empty.");
    return true;
  }catch(e){
    console.error("Failed to load verse_krv.json:", e);
    openAlert(
      "verse_krv.json 로드 실패.\n\n" +
      "체크:\n" +
      "1) index.html과 verse_krv.json이 같은 폴더(루트)에 있는지\n" +
      "2) GitHub Pages에서 /verse_krv.json 이 열리는지\n" +
      "3) JSON 문법 오류가 없는지\n\n" +
      `오류: ${String(e)}`
    );
    return false;
  }
}

/* ========== Selects ========== */
function fillSelect(el, items, placeholder){
  el.innerHTML = "";
  if(!items || items.length === 0){
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = placeholder || "없음";
    el.appendChild(opt);
    return;
  }
  for(const v of items){
    const opt = document.createElement("option");
    opt.value = v;
    opt.textContent = v;
    el.appendChild(opt);
  }
}

function getBooks(){ return Object.keys(BIBLE || {}); }
function getChapters(book){
  const ch = (BIBLE && BIBLE[book]) ? Object.keys(BIBLE[book]) : [];
  return ch.sort((a,b)=>Number(a)-Number(b));
}
function getVerses(book, chap){
  const obj = (BIBLE && BIBLE[book] && BIBLE[book][chap]) ? BIBLE[book][chap] : {};
  const vs = Object.keys(obj);
  return vs.sort((a,b)=>Number(a)-Number(b));
}

function initSelectors(){
  const books = getBooks();
  fillSelect(bookSel, books, "권 없음");

  bookSel.onchange = ()=>{ sel.book = bookSel.value; updateChapters(); updateStatus(); };
  chapSel.onchange = ()=>{ sel.chap = chapSel.value; updateVerses(); updateStatus(); };
  verseSel.onchange = ()=>{ sel.verse = verseSel.value; updateStatus(); };

  sel.book = bookSel.value;
  updateChapters();
  updateStatus();
}
function updateChapters(){
  const chaps = getChapters(bookSel.value);
  fillSelect(chapSel, chaps, "장 없음");
  sel.chap = chapSel.value;
  updateVerses();
}
function updateVerses(){
  const verses = getVerses(bookSel.value, chapSel.value);
  fillSelect(verseSel, verses, "절 없음");
  sel.verse = verseSel.value;
}
function updateStatus(){
  statusSel.textContent = (sel.book && sel.chap && sel.verse) ? `${sel.book} ${sel.chap}:${sel.verse}` : "-";
  statusN.textContent = String(settings.n);
  nPill.textContent = `N=${settings.n}`;
}

/* ========== Dynamic font by N ========== */
function applyDynamicFontByN(n){
  const clamped = Math.max(5, Math.min(10, Number(n)));
  // N=5 -> 15px, N=10 -> 12px
  const font = 15 - (clamped - 5) * (3/5);
  document.documentElement.style.setProperty("--verse-font", `${font.toFixed(2)}px`);
  settings.n = clamped;
  updateStatus();
}

/* ========== Build consecutive set (end-of-chapter allowed) ========== */
function buildConsecutiveSet(book, chap, startVerse, n){
  const verses = getVerses(book, chap).map(v=>Number(v));
  const start = Number(startVerse);
  const startIdx = verses.indexOf(start);
  if(startIdx < 0) return null;

  const slice = verses.slice(startIdx, startIdx + n); // may be shorter at end
  if(slice.length === 0) return null;

  const chapterObj = BIBLE[book][chap];
  return slice.map((v,i)=>({
    id: `${book}|${chap}|${v}`,
    book, chap, verse: String(v),
    ref: `${book} ${chap}:${v}`,
    text: (chapterObj[String(v)] ?? "").trim(),
    orderIndex: i
  }));
}

function shuffleArray(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}

function isCorrectOrder(){
  if(shuffled.length !== correctSet.length) return false;
  return shuffled.every((it, idx)=> it.id === correctSet[idx].id);
}

/* ========== Persistence (v01 key rule retained) ========== */
function savePlayState(){
  try{
    const payload = { book: sel.book, chap: sel.chap, verse: sel.verse, n: settings.n };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
  }catch(e){
    console.warn("Failed to save state:", e);
  }
}
function loadPlayState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return null;
    const obj = JSON.parse(raw);
    if(!obj || !obj.book || !obj.chap || !obj.verse) return null;
    return obj;
  }catch(e){
    return null;
  }
}
function applyStateToSelectors(state){
  if(!BIBLE) return false;
  if(!(state.book in BIBLE)) return false;
  if(!(state.chap in BIBLE[state.book])) return false;
  if(!(state.verse in BIBLE[state.book][state.chap])) return false;

  // N
  const n = Number(state.n);
  if(Number.isFinite(n)) applyDynamicFontByN(n);

  bookSel.value = state.book;
  sel.book = state.book;

  updateChapters();
  chapSel.value = state.chap;
  sel.chap = state.chap;

  updateVerses();
  verseSel.value = state.verse;
  sel.verse = state.verse;

  updateStatus();
  return true;
}

/* ========== Drag reorder (pointer-based sortable) ========== */
let dragState = {
  active: false,
  dragId: null,
  startY: 0,
  currentIndex: -1
};

function renderGameList(){
  gameList.innerHTML = "";

  for (const it of shuffled){
    const row = document.createElement("div");
    row.className = "item";
    row.dataset.id = it.id;

    const grab = document.createElement("div");
    grab.className = "grab";
    grab.textContent = "≡";
    grab.title = "드래그로 이동";

    const text = document.createElement("div");
    text.className = "text";
    text.textContent = it.text || "(본문 텍스트 없음)";

    row.appendChild(grab);
    row.appendChild(text);

    // pointer dragging: start on row or handle
    row.addEventListener("pointerdown", (e)=> onPointerDown(e, row));
    gameList.appendChild(row);
  }
}

function indexFromY(clientY){
  const items = Array.from(gameList.querySelectorAll(".item"));
  const positions = items.map(el => {
    const r = el.getBoundingClientRect();
    return { el, mid: r.top + r.height/2 };
  });
  let idx = positions.findIndex(p => clientY < p.mid);
  if(idx === -1) idx = positions.length - 1;
  return idx;
}

function onPointerDown(e, row){
  // only left click / primary touch
  if (e.button !== undefined && e.button !== 0) return;

  const id = row.dataset.id;
  const idx = shuffled.findIndex(x=>x.id===id);
  if(idx < 0) return;

  dragState.active = true;
  dragState.dragId = id;
  dragState.startY = e.clientY;
  dragState.currentIndex = idx;

  row.classList.add("dragging");
  row.setPointerCapture(e.pointerId);

  row.addEventListener("pointermove", onPointerMove);
  row.addEventListener("pointerup", onPointerUp);
  row.addEventListener("pointercancel", onPointerUp);
}

function onPointerMove(e){
  if(!dragState.active) return;

  const fromIdx = shuffled.findIndex(x=>x.id===dragState.dragId);
  if(fromIdx < 0) return;

  const toIdx = indexFromY(e.clientY);
  if(toIdx === fromIdx) return;

  const [moved] = shuffled.splice(fromIdx, 1);
  shuffled.splice(toIdx, 0, moved);

  renderGameList();
  // mark dragged element
  const el = gameList.querySelector(`.item[data-id="${CSS.escape(dragState.dragId)}"]`);
  if(el) el.classList.add("dragging");
}

function onPointerUp(e){
  dragState.active = false;
  dragState.dragId = null;

  const items = Array.from(gameList.querySelectorAll(".item"));
  items.forEach(el => el.classList.remove("dragging"));

  // Clean up listeners on the element that had capture (best effort)
  const target = e.currentTarget;
  if(target && target.removeEventListener){
    target.removeEventListener("pointermove", onPointerMove);
    target.removeEventListener("pointerup", onPointerUp);
    target.removeEventListener("pointercancel", onPointerUp);
  }
}

/* ========== Game actions ========== */
function startGame(){
  sel.book = bookSel.value;
  sel.chap = chapSel.value;
  sel.verse = verseSel.value;

  const set = buildConsecutiveSet(sel.book, sel.chap, sel.verse, settings.n);
  if(!set){
    openAlert("선택한 절을 찾을 수 없습니다. (데이터를 확인하세요)");
    return;
  }

  correctSet = set;
  shuffled = shuffleArray(set);

  const start = Number(sel.verse);
  const endVerse = Number(set[set.length-1].verse);
  gameRef.textContent = `${sel.book} ${sel.chap}:${start} ~ ${sel.book} ${sel.chap}:${endVerse} (총 ${set.length}절, 설정 N=${settings.n})`;

  renderGameList();
  openGameModal();

  // v01 save time: when starting the game
  savePlayState();
}

function replay(){
  if(!correctSet.length) return;
  shuffled = shuffleArray(correctSet);
  renderGameList();
}

function openResult(){
  if(!correctSet.length) return;
  const ok = isCorrectOrder();
  const badge = ok
    ? `<div class="resultBadge success">성공 (PASS) ✅</div>`
    : `<div class="resultBadge fail">실패 (FAIL) ❌</div>`;

  const body = `
    ${badge}
    <div class="hintBox" style="margin:0">
      ${ok ? "정답 순서입니다!" : "순서가 맞지 않습니다. 드래그로 다시 정렬해 보세요."}
    </div>
  `;

  const closeBtn = mkButton("닫기", "primary", closeModal);
  openModal("게임 결과", body, [closeBtn]);
}

function openAnswer(){
  if(!correctSet.length) return;

  const lines = correctSet.map(v=>`
    <div class="answerLine">
      <div class="meta">${escapeHtml(v.ref)}</div>
      <div class="text">${escapeHtml(v.text || "(본문 텍스트 없음)")}</div>
    </div>
  `).join("");

  const body = `
    <div class="resultBadge warn">정답 화면</div>
    <div class="hintBox" style="margin-top:0">아래는 올바른 순서(정답)입니다.</div>
    <div style="height:10px"></div>
    ${lines}
  `;

  const closeBtn = mkButton("닫기", "primary", closeModal);
  openModal("정답 화면", body, [closeBtn]);
}

/* ========== Settings (only N: 5~10) ========== */
function openSettings(){
  const body = `
    <div class="resultBadge warn">게임 설정</div>
    <div style="display:grid;grid-template-columns:160px 1fr;gap:10px;align-items:center">
      <div style="color:var(--sub);font-size:13px">연속 구절 수 (N)</div>
      <div>
        <select id="nSel">
          ${[5,6,7,8,9,10].map(v=>`<option value="${v}" ${v===settings.n?"selected":""}>${v}</option>`).join("")}
        </select>
      </div>
    </div>
    <div class="hintBox">
      • 최소 5, 최대 10<br/>
      • 장 끝이면 N보다 적어도 게임 진행 허용
    </div>
  `;

  const cancelBtn = mkButton("취소", "", closeModal);
  const saveBtn = mkButton("저장", "primary", ()=>{
    const nSel = document.getElementById("nSel");
    const n = Number(nSel?.value ?? 5);
    applyDynamicFontByN(n);

    // v01 save time: when saving settings
    savePlayState();

    closeModal();
    openAlert("설정이 저장되었습니다.");
  });

  openModal("게임 설정", body, [cancelBtn, saveBtn]);
}

/* ========== Wire buttons ========== */
startBtn.addEventListener("click", startGame);
settingsBtn.addEventListener("click", openSettings);

btnCheck.addEventListener("click", openResult);
btnReplay.addEventListener("click", replay);
btnAnswer.addEventListener("click", openAnswer);

/* ========== Boot ========== */
(async function boot(){
  applyDynamicFontByN(settings.n);

  const ok = await loadData();
  if(!ok) return;

  initSelectors();

  // Restore (book/chap/verse(start)/N)
  const state = loadPlayState();
  if(state && applyStateToSelectors(state)){
    // keep selection restored; user can press start to open popup
    // (If you want auto-open game, tell me and I’ll change it.)
  }
})();
</script>
</body>
</html>
